<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain_WriteUps on Dimitris Vagiakakos SV1SJP</title><link>/blockchain_writeups/</link><description>Recent content in Blockchain_WriteUps on Dimitris Vagiakakos SV1SJP</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>All rights reserved, TuxHouse Educational Technologies - Dimitris LinuxOS - 2011-2023</copyright><lastBuildDate>Sat, 04 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/blockchain_writeups/index.xml" rel="self" type="application/rss+xml"/><item><title>War Of Array</title><link>/blockchain_writeups/warofarray/</link><pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate><guid>/blockchain_writeups/warofarray/</guid><description>On this challenge, we have the smart-contract WarOfArray and we are requested to claim the ownership of the contract, and then add 2 numbers on the &amp;ldquo;myArray&amp;rdquo; array. Using Remix IDE from remix.ethereum.org is recommended on this challenge.
// SPDX-License-Identifier: GPL-3.0-or-later pragma solidity 0.8.18; contract WarOfArray { uint[] public myArray; address public owner; constructor() { owner = address(0x1234567890123456789012345678901234567890); } function addToMyArray(uint _value) public { require(msg.sender == owner, &amp;#34;Only the contract owner can add to the array&amp;#34;); myArray.</description></item><item><title>Reeintrancy - Ethernaut</title><link>/blockchain_writeups/reeinctancy/</link><pubDate>Tue, 01 Feb 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/reeinctancy/</guid><description>On this challenge, we will learn how the infamous DAO occured and how to prevent such an incident to occur again. Ethereum splitted into two Blockchains, Ethereum and Ethereum Classic because of a DAO Attack. So we have this smart-contract and we have to withdraw all of it&amp;rsquo;s ether:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Reentrance { using SafeMath for uint256; mapping(address =&amp;gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].</description></item><item><title>Recovery - Ethernaut</title><link>/blockchain_writeups/recovery/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/recovery/</guid><description>On this challenge, we have a smart-contract that can built very simple tokens by its own. Anyone can create new tokens with ease. The point of this contract is to find the lost contract address and then withdraw all of its ether. At first, we check the code:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.</description></item><item><title>Privacy - Ethernaut</title><link>/blockchain_writeups/privacy/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/privacy/</guid><description>On this challenge, we have to unlock a vault again, but this is a more advanced one.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</description></item><item><title>CoinFlip - Ethernaut</title><link>/blockchain_writeups/coinflip/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/coinflip/</guid><description>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.</description></item><item><title>Vault - Ethernaut</title><link>/blockchain_writeups/vault/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/vault/</guid><description>On this challenge, we have to unlock the vault to win the challenge.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } First of all, we can see that we have 2 state variables. One of them is the locked variable which is public.</description></item><item><title>King - Ethernaut</title><link>/blockchain_writeups/king/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/king/</guid><description>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.</description></item><item><title>Naught Coin - Ethernaut</title><link>/blockchain_writeups/naught-coin/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/naught-coin/</guid><description>So now we have the challenge &amp;ldquo;Naught Coin&amp;rdquo;. Naught Coin is an ERC20 token and we are already holding all of them. The catch is that we will only be able to transfer them after a 10 year lockout period. Can we figure out how to get them out to another address so that we can transfer them freely? So, we have NaughtCoins locked for a 10 year period. We have to unlock them and then, get them to an another address.</description></item><item><title>Force - Ethernaut</title><link>/blockchain_writeups/force/</link><pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/force/</guid><description>We have an empty smart-contract without any functions, constructor or even Fallback Function. Our goal is to send some Ether to it.
Ethereum smart-contracts typically they have 3 ways to receive ether from an another address.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /\_/\ / ____/ o o \ /~____ =Ã¸= / (______)__m_m) */} As we have already mentioned, by using a payable function. We don&amp;rsquo;t have any kind of function on this smart-contract so we cannot use this way.</description></item><item><title>Fallback - Ethernaut</title><link>/blockchain_writeups/fallback/</link><pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate><guid>/blockchain_writeups/fallback/</guid><description>We have the smart-contract Fallback and we are requested to claim the ownership of the contract, and then reduce it&amp;rsquo;s balance to 0. At first, let&amp;rsquo;s read the smart contract&amp;rsquo;s code and search if something interesting is going on there:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Fallback { using SafeMath for uint256; mapping(address =&amp;gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.</description></item></channel></rss>