<!doctype html><html lang=en><head><title>Blockchain_WriteUps :: DimitrisV SV1SJP</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content="linux"><meta name=robots content="noodp"><link rel=canonical href=/blockchain_writeups/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/pink.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Blockchain_WriteUps"><meta property="og:description" content><meta property="og:url" content="/blockchain_writeups/"><meta property="og:site_name" content="DimitrisV SV1SJP"><meta property="og:image" content="/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/blockchain_writeups/index.xml rel=alternate type=application/rss+xml title="DimitrisV SV1SJP"></head><body class=pink><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>DimitrisV SV1SJP</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about.html>About</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about.html>About</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/reeinctancy/>Reeintrancy - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-02-01</span>
<span class=post-author>:: DimitrisV && Stavros Gkinos</span></div><div class=post-content>On this challenge, we will learn how the infamous DAO occured and how to prevent such an incident to occur again. Ethereum splitted into two Blockchains, Ethereum and Ethereum Classic because of a DAO Attack. So we have this smart-contract and we have to withdraw all of it’s ether:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address => uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].</div><div><a class="read-more button" href=/blockchain_writeups/reeinctancy/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/recovery/>Recovery - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-30</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have a smart-contract that can built very simple tokens by its own. Anyone can create new tokens with ease. The point of this contract is to find the lost contract address and then withdraw all of its ether. At first, we check the code:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.</div><div><a class="read-more button" href=/blockchain_writeups/recovery/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/privacy/>Privacy - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-26</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have to unlock a vault again, but this is a more advanced one.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</div><div><a class="read-more button" href=/blockchain_writeups/privacy/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/coinflip/>CoinFlip - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-15</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import '@openzeppelin/contracts/math/SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.</div><div><a class="read-more button" href=/blockchain_writeups/coinflip/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/vault/>Force - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-08</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have to unlock the vault to win the challenge.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } First of all, we can see that we have 2 state variables. One of them is the locked variable which is public.</div><div><a class="read-more button" href=/blockchain_writeups/vault/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/king/>King - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-07</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.</div><div><a class="read-more button" href=/blockchain_writeups/king/>Read more stuff →</a></div></div><div class=pagination><div class=pagination__buttons><span class="button next"><a href=/blockchain_writeups/page/2/><span class=button__text>Older posts</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Dimitris LinuxOS 2011-2022</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
<script src=/assets/languageSelector.js></script></div></body></html>