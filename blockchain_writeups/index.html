<!doctype html><html lang=en><head><title>Blockchain_WriteUps :: DimitrisV SV1SJP</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content="linux"><meta name=robots content="noodp"><link rel=canonical href=/blockchain_writeups/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/pink.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Blockchain_WriteUps"><meta property="og:description" content><meta property="og:url" content="/blockchain_writeups/"><meta property="og:site_name" content="DimitrisV SV1SJP"><meta property="og:image" content="/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/blockchain_writeups/index.xml rel=alternate type=application/rss+xml title="DimitrisV SV1SJP"></head><body class=pink><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>DimitrisV SV1SJP</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about.html>About</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about.html>About</a></li><li><a href=/blockchain_camera>Blockchain Camera</a></li><li><a href=/blockchain_writeups>Blockchain WriteUps</a></li><li><a href=/panellinies_aepp/index.html>Panellinies_AEPP</a></li><li><a href=/projects>Projects</a></li><li><a href=/ubuntel>Ubuntel</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/reeinctancy/>Reeintrancy - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-02-01</span>
<span class=post-author>:: DimitrisV && Stavros Gkinos</span></div><div class=post-content>On this challenge, we will learn how the infamous DAO occured and how to prevent such an incident to occur again. Ethereum splitted into two Blockchains, Ethereum and Ethereum Classic because of a DAO Attack. So we have this smart-contract and we have to withdraw all of it’s ether:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Reentrance { using SafeMath for uint256; mapping(address => uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].</div><div><a class="read-more button" href=/blockchain_writeups/reeinctancy/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/recovery/>Recovery - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-30</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have a smart-contract that can built very simple tokens by its own. Anyone can create new tokens with ease. The point of this contract is to find the lost contract address and then withdraw all of its ether. At first, we check the code:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Recovery { //generate tokens function generateToken(string memory _name, uint256 _initialSupply) public { new SimpleToken(_name, msg.</div><div><a class="read-more button" href=/blockchain_writeups/recovery/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/privacy/>Privacy - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-26</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have to unlock a vault again, but this is a more advanced one.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; constructor(bytes32[3] memory _data) public { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</div><div><a class="read-more button" href=/blockchain_writeups/privacy/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/coinflip/>CoinFlip - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-15</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>Coin flip is a basic game that we throw a coin and we have 50% chance of being 0 or 1. In order to win this game we need 10 consecutive wins. To begin with, we check the code of the smart-contract to find some useful stuff:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; import '@openzeppelin/contracts/math/SafeMath.sol'; contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.</div><div><a class="read-more button" href=/blockchain_writeups/coinflip/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/vault/>Vault - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-08</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>On this challenge, we have to unlock the vault to win the challenge.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.11; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } First of all, we can see that we have 2 state variables. One of them is the locked variable which is public.</div><div><a class="read-more button" href=/blockchain_writeups/vault/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/king/>King - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-07</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>We have a smart contract game called Kings. This contract is a classic example of a ponzi scheme. Whoever sends an amount of ether that is more than the current prize becomes the new king. On such an event, the overthrown king gets paid the new prize, making a bit of ether in the process.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.</div><div><a class="read-more button" href=/blockchain_writeups/king/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/naught-coin/>Naught Coin - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-06</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>So now we have the challenge “Naught Coin”. Naught Coin is an ERC20 token and we are already holding all of them. The catch is that we will only be able to transfer them after a 10 year lockout period. Can we figure out how to get them out to another address so that we can transfer them freely? So, we have NaughtCoins locked for a 10 year period. We have to unlock them and then, get them to an another address.</div><div><a class="read-more button" href=/blockchain_writeups/naught-coin/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/force/>Force - Ethernaut</a></h1><div class=post-meta><span class=post-date>2022-01-02</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>We have an empty smart-contract without any functions, constructor or even Fallback Function. Our goal is to send some Ether to it.
Ethereum smart-contracts typically they have 3 ways to receive ether from an another address.
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Force {/* MEOW ? /_/\ / <strong><strong>/ o o \ /~</strong></strong> =ø= / (______)__m_m) */} As we have already mentioned, by using a payable function. We don’t have any kind of function on this smart-contract so we cannot use this way.</div><div><a class="read-more button" href=/blockchain_writeups/force/>Read more stuff →</a></div></div><div class="post on-list"><h1 class=post-title><a href=/blockchain_writeups/fallback/>Fallback - Ethernaut</a></h1><div class=post-meta><span class=post-date>2021-12-19</span>
<span class=post-author>:: DimitrisV</span></div><div class=post-content>We have the smart-contract Fallback and we are requested to claim the ownership of the contract, and then reduce it’s balance to 0. At first, let’s read the smart contract’s code and search if something interesting is going on there:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; import '@openzeppelin/contracts/math/SafeMath.sol'; contract Fallback { using SafeMath for uint256; mapping(address => uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.</div><div><a class="read-more button" href=/blockchain_writeups/fallback/>Read more stuff →</a></div></div><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Dimitris LinuxOS - TuxHouse - 2011-2023</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
<script src=/assets/languageSelector.js></script></div></body></html>